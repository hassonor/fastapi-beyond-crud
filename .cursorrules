# FastAPI Backend — Cursor Rules

## Role and Expertise

You are an expert Python FastAPI developer. You build modern, high-performance REST APIs with automatic documentation, type safety, and async patterns. Your code is production-ready, well-tested, and follows Python best practices.

## Project Overview

This is a backend API built with FastAPI, implementing RESTful endpoints with Pydantic models, SQLAlchemy ORM, async database access, and comprehensive data validation. It emphasizes developer experience with automatic OpenAPI documentation.

## Code Style

### General Principles
- Follow **PEP 8** for all code style decisions.
- Follow **PEP 257** for docstring conventions.
- Use **Google-style docstrings** for all public functions and classes.
- Write idiomatic **async/await** code for I/O operations.
- Maximum line length of **120 characters**.
- Use **type hints** for all function parameters and return types.
- Use **f-strings** for string formatting.
- Prefer **explicit over implicit** (FastAPI philosophy).

### Naming Conventions
- **Variables and functions**: `snake_case`
- **Classes**: `PascalCase`
- **Constants**: `UPPER_SNAKE_CASE`
- **Files and directories**: `snake_case`
- **Private members**: prefix with single underscore `_`
- **Router prefixes**: lowercase with hyphens (`/api/v1/users`, `/health-check`)
- Use descriptive names with auxiliary verbs (e.g., `is_valid`, `has_permission`, `can_access`)

### Type Hints
- Use **type hints** for all function parameters and return types.
- Use **Pydantic models** for request/response schemas (automatic validation).
- Use `Optional[Type]` or `Type | None` for nullable values.
- Use `list[str]` and `dict[str, int]` syntax (Python 3.9+).
- Use **NewType** for semantic type aliases (e.g., `UserId = NewType("UserId", str)`).

## Project Structure

```
project/
├── app/
│   ├── main.py              # FastAPI app initialization
│   ├── config.py            # Configuration (Pydantic Settings)
│   ├── dependencies.py      # Shared dependencies (DB session, auth)
│   ├── api/
│   │   ├── v1/              # API version 1 routes
│   │   │   ├── endpoints/   # Route handlers
│   │   │   └── router.py    # APIRouter aggregation
│   ├── core/
│   │   ├── security.py      # Auth, password hashing
│   │   └── database.py      # DB connection, session
│   ├── models/              # SQLAlchemy models
│   ├── schemas/             # Pydantic schemas
│   ├── crud/                # Database operations
│   ├── services/            # Business logic
│   └── utils/               # Utility functions
├── tests/                   # Test suite
├── alembic/                 # Database migrations
└── requirements.txt         # Dependencies
```

## FastAPI Patterns

### Route Handlers
- Use **async def** for all route handlers (unless CPU-bound).
- Use **dependency injection** with `Depends()` for shared logic.
- Use **path parameters** for resource identification (`/users/{user_id}`).
- Use **query parameters** for filtering, pagination, sorting.
- Use **request body** for create/update operations (Pydantic models).
- Return **Pydantic models** for automatic serialization and docs.

### Dependency Injection Example
```python
from fastapi import Depends, HTTPException
from sqlalchemy.orm import Session

def get_db() -> Generator[Session, None, None]:
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@router.get("/users/{user_id}", response_model=UserResponse)
async def get_user(
    user_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user
```

## Pydantic Models

- Use **Pydantic BaseModel** for all request/response schemas.
- Use **Field()** for validation, defaults, examples.
- Use **validators** for complex validation logic.
- Separate **request** and **response** models (e.g., `UserCreate`, `UserResponse`).
- Use **Config** class for ORM mode, schema extras.
- Use **EmailStr**, **HttpUrl** for built-in validation.

### Pydantic Example
```python
from pydantic import BaseModel, Field, EmailStr, validator

class UserCreate(BaseModel):
    username: str = Field(..., min_length=3, max_length=50)
    email: EmailStr
    password: str = Field(..., min_length=8)

    @validator("password")
    def password_strength(cls, v):
        if not any(c.isupper() for c in v):
            raise ValueError("Password must contain uppercase letter")
        return v

class UserResponse(BaseModel):
    id: int
    username: str
    email: EmailStr
    is_active: bool

    class Config:
        orm_mode = True  # Allow SQLAlchemy models
```

## Error Handling

- Use **HTTPException** for HTTP errors with proper status codes.
- Implement **custom exception handlers** for domain-specific errors.
- Use **early returns** and **guard clauses** to reduce nesting.
- Provide **detailed error messages** with context (avoid exposing internals).
- Log errors with **structured logging** (JSON format).
- Use **ValidationError** for Pydantic validation (automatic).

### Custom Exception Example
```python
from fastapi import HTTPException, Request
from fastapi.responses import JSONResponse

class UserNotFoundError(Exception):
    def __init__(self, user_id: int):
        self.user_id = user_id

@app.exception_handler(UserNotFoundError)
async def user_not_found_handler(request: Request, exc: UserNotFoundError):
    return JSONResponse(
        status_code=404,
        content={"detail": f"User {exc.user_id} not found"}
    )
```

## Async Database Access

- Use **async database drivers** (asyncpg for PostgreSQL, aiomysql for MySQL).
- Use **SQLAlchemy 2.0** async ORM or **SQLModel**.
- Use **async with** for database sessions (automatic cleanup).
- Avoid **blocking I/O** in async functions (use asyncio.to_thread if needed).
- Use **connection pooling** with appropriate limits.

### Async DB Example
```python
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker

engine = create_async_engine("postgresql+asyncpg://user:pass@localhost/db")
AsyncSessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

async def get_async_db() -> AsyncGenerator[AsyncSession, None]:
    async with AsyncSessionLocal() as session:
        yield session
```

## Authentication & Authorization

- Use **OAuth2** with **JWT tokens** for authentication.
- Store **hashed passwords** (use `passlib` with `bcrypt`).
- Use **security dependencies** for protected endpoints.
- Implement **role-based access control** (RBAC) with dependencies.
- Use **HTTPBearer** for token authentication.
- Set **token expiration** and **refresh tokens**.

## Testing Standards

- Write **unit tests** for services and utilities with **pytest**.
- Write **integration tests** for API endpoints with **TestClient**.
- Use **pytest fixtures** for shared setup (database, auth).
- Use **pytest-asyncio** for async tests.
- Mock **external dependencies** (third-party APIs, email).
- Aim for **80%+ code coverage** on critical paths.
- Use **factory patterns** for test data generation.

### Testing Example
```python
from fastapi.testclient import TestClient

def test_create_user(client: TestClient):
    response = client.post(
        "/api/v1/users/",
        json={"username": "testuser", "email": "test@example.com", "password": "Test1234"}
    )
    assert response.status_code == 201
    data = response.json()
    assert data["username"] == "testuser"
    assert "id" in data
```

## Clean Code Principles

- **Single Responsibility**: Each function, class, service should have one purpose.
- **DRY**: Extract repeated logic into utilities or base classes.
- **Meaningful Names**: Names should reveal intent without comments.
- **Small Functions**: Functions should do one thing well (max 20-30 lines).
- **Dependency Inversion**: Depend on abstractions (protocols), not concrete classes.
- **Separation of Concerns**: Controllers (routes) → Services (business logic) → CRUD (data access).

## Documentation Standards

- Every module should have a **module-level docstring**.
- Every public function and class should have **Google-style docstrings**.
- FastAPI **auto-generates OpenAPI docs** at `/docs` and `/redoc`.
- Use **tags** to organize endpoints in docs.
- Use **summary** and **description** in route decorators.
- Use **response_model** for automatic response documentation.
- Provide **examples** in Pydantic schemas with `Config.schema_extra`.

### Documentation Example
```python
@router.post(
    "/users/",
    response_model=UserResponse,
    status_code=201,
    tags=["users"],
    summary="Create a new user",
    description="Create a new user with username, email, and password. Password must be at least 8 characters."
)
async def create_user(user: UserCreate, db: Session = Depends(get_db)):
    """Create a new user account."""
    # Implementation...
```

## API Best Practices

- Version APIs with **path prefix** (`/api/v1/`).
- Implement **health checks** (`/health`, `/readiness`).
- Use **CORS middleware** for frontend integration.
- Implement **rate limiting** for public endpoints.
- Use **pagination** for list endpoints (limit/offset or cursor-based).
- Implement **filtering** and **sorting** with query parameters.
- Use **background tasks** for async operations (email, notifications).
- Enable **compression** middleware (gzip) for responses.

## Performance Optimization

- Use **async** for all I/O operations (database, HTTP, file).
- Use **Redis** for caching frequently accessed data.
- Implement **database query optimization** (select only needed fields, eager loading).
- Use **connection pooling** for database connections.
- Enable **response compression** (gzip middleware).
- Use **streaming responses** for large data transfers.
- Profile with **py-spy** or **cProfile** for CPU bottlenecks.
